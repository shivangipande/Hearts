<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Apple Style Liquid Glass Button</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body>
  <script>
    let buttonX, buttonY;
    let isDragging = false;
    let offsetX, offsetY;

    function setup() {
      pixelDensity(2);
      createCanvas(windowWidth, windowHeight);
      buttonX = width / 2;
      buttonY = height / 2;
    }

    function draw() {
      drawBackground();
      drawGlass(buttonX, buttonY);
    }

    function drawBackground() {
      background(30, 60, 114);
      let time = millis() * 0.0008;
      for (let y = 0; y < height; y += 2) {
        let wave1 = sin(y * 0.015 + time * 3) * 40;
        let wave2 = cos(y * 0.012 + time * 2.3) * 35;
        let r = 60 + wave1 + sin(time + y * 0.01) * 30;
        let g = 90 + wave2 + cos(time * 1.2 + y * 0.008) * 40;
        let b = 180 + sin(y * 0.008 + time * 1.8) * 60;
        stroke(r, g, b);
        strokeWeight(2);
        line(0, y, width, y);
      }
    }

    // drawGlass with blur underneath barrel distortion
    function drawGlass(x, y) {
      let baseSize = min(windowWidth, windowHeight) * 0.4;
      let size = constrain(baseSize, 140, 240);
      let radius = size / 2;

      // Get background
      let bg = get(x - radius, y - radius, size, size);

      drawingContext.save();
      drawingContext.shadowColor = 'rgba(0, 0, 0, 0.25)';
      drawingContext.shadowBlur = 10;
      drawingContext.shadowOffsetX = 4;
      drawingContext.shadowOffsetY = 6;
      stroke(0, 0, 0, 40);
      strokeWeight(2);
      noFill();
      circle(x, y, size);
      drawingContext.restore();

      let ctx = drawingContext;
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, TWO_PI);
      ctx.clip();

      // Blurred background frosting layer
      ctx.filter = 'blur(12px) saturate(1.05)';
      ctx.globalAlpha = 0.5;
      image(bg, x - radius, y - radius);
      ctx.filter = 'none';
      ctx.globalAlpha = 1.0;

      // Barrel distortion
      let step = windowWidth < 600 ? 1 : 0.5;
      for (let px = 0; px < size; px += step) {
        for (let py = 0; py < size; py += step) {
          let cx = size / 2;
          let cy = size / 2;
          let d = dist(px, py, cx, cy);
          if (d <= radius) {
            let nd = d / radius;
            let k1 = 0.35;
            let distortion = 1 + k1 * nd * nd;
            let angle = atan2(py - cy, px - cx);
            let sd = d / distortion;
            let sx = cx + cos(angle) * sd;
            let sy = cy + sin(angle) * sd;
            sx = constrain(sx, 0, bg.width - 1);
            sy = constrain(sy, 0, bg.height - 1);
            let c = bg.get(sx, sy);

            if (nd > 0.9 && windowWidth > 600) {
              let ab = (nd - 0.9) * 0.05;
              let rc = bg.get(constrain(sx + ab, 0, bg.width - 1), sy);
              let bc = bg.get(constrain(sx - ab, 0, bg.width - 1), sy);
              fill(red(rc), green(c), blue(bc), 160);
            } else {
              fill(...c, 160);
            }

            noStroke();
            rect(x - radius + px, y - radius + py, step, step);
          }
        }
      }

      ctx.restore();

      // Subtle internal light specks
      for (let i = 0; i < 20; i++) {
        let angle = random(TWO_PI);
        let r = random(radius);
        let nx = x + cos(angle) * r;
        let ny = y + sin(angle) * r;
        fill(255, 255, 255, random(3, 8));
        noStroke();
        circle(nx, ny, random(0.2, 0.7));
      }

      // Spectral edge
      let mouseAngle = atan2(mouseY - y, mouseX - x);
      drawCircleSpectralEdge(x, y, radius, mouseAngle);

      stroke(255, 255, 255, 50);
      strokeWeight(0.5);
      noFill();
      circle(x, y, size);
    }

    function drawCircleSpectralEdge(cx, cy, r, angle) {
      let ctx = drawingContext;
      let gx1 = cx + cos(angle) * 120;
      let gy1 = cy + sin(angle) * 120;
      let gx2 = cx + cos(angle + PI) * 120;
      let gy2 = cy + sin(angle + PI) * 120;

      let grad = ctx.createLinearGradient(gx1, gy1, gx2, gy2);
      grad.addColorStop(0, 'rgba(255,150,255,0)');
      grad.addColorStop(0.4, 'rgba(255,200,255,0.3)');
      grad.addColorStop(0.5, 'rgba(255,255,255,0.6)');
      grad.addColorStop(0.6, 'rgba(200,255,255,0.3)');
      grad.addColorStop(1, 'rgba(150,255,255,0)');

      ctx.strokeStyle = grad;
      ctx.lineWidth = 2;
      ctx.filter = 'blur(1px)';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, TWO_PI);
      ctx.stroke();
      ctx.filter = 'none';
    }

    function mousePressed() {
      let size = constrain(min(windowWidth, windowHeight) * 0.4, 140, 240);
      if (dist(mouseX, mouseY, buttonX, buttonY) < size / 2) {
        isDragging = true;
        offsetX = mouseX - buttonX;
        offsetY = mouseY - buttonY;
        document.body.style.cursor = 'grabbing';
      }
    }

    function mouseDragged() {
      if (isDragging) {
        buttonX = constrain(mouseX - offsetX, 100, width - 100);
        buttonY = constrain(mouseY - offsetY, 100, height - 100);
      }
    }

    function mouseReleased() {
      isDragging = false;
      document.body.style.cursor = 'default';
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
